/*
 * This file is part of Canvas Renderer and is licensed to the project under
 * terms that are compatible with the GNU Lesser General Public License.
 * See the NOTICE file distributed with this work for additional information
 * regarding copyright ownership and licensing.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package grondag.canvas.terrain.region;

import java.util.Iterator;
import java.util.Set;

import com.google.common.collect.Sets;
import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;

import net.minecraft.Util;

import io.vram.frex.api.config.FlawlessFrames;
import io.vram.sc.unordered.SimpleUnorderedArrayList;

/**
 * Tracks what regions require rebuilding and rebuilds them on demand.
 *
 * <p>Handles regions for both camera and shadow views.  "Near" regions
 * are exclusively a camera-view concept.
 */
public class RegionRebuildManager {
	private final Set<RenderRegion> regionsToRebuild = Sets.newLinkedHashSet();

	/**
	 * Region rebuild requests accumulated on main thread that may impact visibility
	 * but not generated by terrain iteration. These should be processed every frame
	 * before iteration is evaluated.  These regions could be urgent or not, and may
	 * already be scheduled.  They are not built immediately when requested because
	 * many requests could be received in the same frame for the same region.
	 */
	private final Set<RenderRegion> externalBuildRequests = new ObjectOpenHashSet<>();

	public void acceptExternalBuildRequest(RenderRegion region) {
		externalBuildRequests.add(region);
	}

	public void processExternalBuildRequests() {
		if (externalBuildRequests.isEmpty()) {
			return;
		}

		final boolean flawless = FlawlessFrames.isActive();

		for (final RenderRegion region : externalBuildRequests) {
			if (flawless || region.needsRebuild() && !region.isClosed()) {
				if (region.needsImportantRebuild() || region.origin.isNear()) {
					regionsToRebuild.remove(region);
					region.rebuildOnMainThread();
				} else {
					regionsToRebuild.add(region);
				}
			}
		}

		externalBuildRequests.clear();
	}

	/**
	 * Iterates the given list of regions and if a region requires an urgent
	 * rebuild or is near the camera, immediately rebuilds it on the calling
	 * thread (which should always be the render thread), removing the region
	 * from the set of regions scheduled for rebuild.
	 *
	 * <p>Otherwise the region is scheduled for rebuild off thread, unless it
	 * does not require rebuild. (It may have completed rebuild off-thread because
	 * it was scheduled earlier.)
	 *
	 * <p>If a region reports it does not require rebuild or is already scheduled
	 * for rebuild, effectively nothing happens for that region.
	 *
	 * <p>Not thread-safe and meant to be called from the main render thread.
	 *
	 * @param updateRegions list of regions potentially needing rebuilt
	 */
	public void scheduleOrBuild(SimpleUnorderedArrayList<RenderRegion> updateRegions) {
		final int limit = updateRegions.size();
		final Set<RenderRegion> regionsToRebuild = this.regionsToRebuild;

		if (limit == 0) {
			return;
		}

		for (int i = 0; i < limit; ++i) {
			final RenderRegion region = updateRegions.get(i);

			if (region.needsRebuild()) {
				if (region.needsImportantRebuild() || region.origin.isNear()) {
					regionsToRebuild.remove(region);
					region.rebuildOnMainThread();
				} else {
					regionsToRebuild.add(region);
				}
			}
		}
	}

	/**
	 * Rebuilds the region on the calling thread if needed,
	 * also removing it from the set of regions awaiting off-thread
	 * rebuild if it was present.
	 *
	 * <p>Not thread-safe and meant to be called from the main render thread.
	 *
	 * @param region Region to be checked and rebuilt.
	 */
	public void buildNearRegionIfNeeded(RenderRegion region) {
		if (region.needsRebuild()) {
			regionsToRebuild.remove(region);
			region.rebuildOnMainThread();
		}
	}

	/**
	 * Iterates regions awaiting rebuild and rebuilds them on the calling
	 * thread if they are urgent/near.  For non-urgent regions, necessary
	 * world data are captured on the calling thread and packaged into a
	 * rebuild task that runs off thread.
	 *
	 * <p>Not thread-safe and meant to be called from the main render thread.
	 *
	 * @param endNanos The max end time for this task. (NOT the duration.)
	 * Processing will end when the system nanotime exceeds this value.
	 */
	public void processScheduledRegions(long endNanos) {
		final Set<RenderRegion> regionsToRebuild = this.regionsToRebuild;

		//final long start = Util.getMeasuringTimeNano();
		//int builtCount = 0;

		if (!regionsToRebuild.isEmpty()) {
			final Iterator<RenderRegion> iterator = regionsToRebuild.iterator();
			final boolean flawless = FlawlessFrames.isActive();

			while (iterator.hasNext()) {
				final RenderRegion region = iterator.next();

				if (region.isClosed()) {
					iterator.remove();
				} else if (flawless || region.needsImportantRebuild()) {
					region.rebuildOnMainThread();
					iterator.remove();
				} else if (region.renderChunk.areCornersLoaded()) {
					region.prepareAndExecuteRebuildTask();
					iterator.remove();
				}

				// this seemed excessive
				//				++builtCount;
				//
				//				final long now = Util.getMeasuringTimeNano();
				//				final long elapsed = now - start;
				//				final long avg = elapsed / builtCount;
				//				final long remaining = endNanos - now;
				//
				//				if (remaining < avg) {
				//					break;
				//				}

				if (!flawless && Util.getNanos() >= endNanos) {
					break;
				}
			}
		}
	}

	public void clear() {
		regionsToRebuild.clear();
	}

	public boolean isEmpty() {
		return regionsToRebuild.isEmpty();
	}
}
